<html>
    <head>
        <title>SmartMotors Config</title>
        
    </head>
    <boby>
        <button id="button">connectar arduino</button>
        <button id="btnLigar">Ler Serial</button>
        <button id="btnDesligar">Desconectar</button>
        <form>
            Experimento: <span id="spEx"></span><br/>
            Descrição: <span id="spDesc"></span><br/>
            Var1 : <span id="spVar"></span>
        </form>
    </boby>
    <script>
        class LineBreakTransformer {
            constructor() {
                // A container for holding stream data until a new line.
                this.chunks = "";
            }

            transform(chunk, controller) {
                // Append new chunks to existing chunks.
                this.chunks += chunk;
                // For each line breaks in chunks, send the parsed lines out.
                const lines = this.chunks.split("/EOJO");//("\r\n");
                this.chunks = lines.pop();
                lines.forEach((line) => controller.enqueue(line));
            }

            flush(controller) {
                // When the stream is closed, flush any remaining chunks out.
                console.log("flushed");
                controller.enqueue(this.chunks);
            }
        }
        class Experiment{
        
            constructor(){              
                
            }
            async requestPort(){
                this.port = await navigator.serial.requestPort();
            }
            async getAvailablePorts(){
                this.availablePorts = await navigator.serial.getPorts();
                return this.availablePorts;
            }
            async requestInfo(){
               // this.textEncoder = new TextEncoderStream();
               // this.writableStreamClosed = textEncoder.readable.pipeTo(port.writable);
               
                
                this.writer = this.textEncoder.writable.getWriter();  
                
                await this.writer.write("{\"action\": \"update\"}");
                await this.writer.close();
                await this.writableStreamClosed;
                await this.writer.releaseLock();
                
            }
            async readSerial(){
                while (this.port.readable){
                   // this.textDecoder = new TextDecoderStream();
                   // this.readableStreamClosed = this.port.readable.pipeTo(this.textDecoder.writable);     
                   console.log(this.textDecoder);
                   console.log(this.textEncoder);  
                    this.reader = this.textDecoder.readable
                        .pipeThrough(new TransformStream(new LineBreakTransformer()))
                        .getReader();
                    
                    while (true) {
                        const { value, done } = await this.reader.read();                 
                        if (done) {
                            this.reader.releaseLock();
                            break;
                        }
                        let jsons = value;
                        console.log(jsons);
                        let jsonObj = JSON.parse(jsons);
                        document.getElementById("spEx").innerHTML = jsonObj.name;
                        document.getElementById("spDesc").innerHTML = jsonObj.desc;
                        document.getElementById("spVar").innerHTML = jsonObj.variables[0].value;
                        console.log(jsonObj);
                    }
                }
            }
        }
        
        window.addEventListener('load', async function(event){
            
            const obj = new Experiment();
            let ports = await obj.getAvailablePorts();
            if(ports.length > 0){
                obj.port = ports[0];
                obj.port.onconnect = document.getElementById("button").setAttribute("disabled", true);
                await obj.port.open({ baudRate: 9600 });
                obj.textDecoder = new TextDecoderStream();
                obj.textEncoder = new TextEncoderStream();
                obj.readableStreamClosed = obj.port.readable.pipeTo(obj.textDecoder.writable);   
                obj.writableStreamClosed = obj.textEncoder.readable.pipeTo(obj.port.writable); 
                console.log(obj);
                          
            }
            
            document.getElementById("button").addEventListener('click', async() => {
                if(!obj.port){
                    await obj.requestPort();
                    if(obj.port){
                        if (!obj.port.readable){
                            await obj.port.open({ baudRate: 9600 });
                            console.log("conexao com a porta aberta");
                        }
                    }
                }       
            });

            document.getElementById("btnLigar").addEventListener('click', async() => {
                await obj.requestInfo();
                await obj.readSerial();
            });

            document.getElementById("btnDesligar").addEventListener('click', async() => {
                obj.reader.cancel();
                await obj.readableStreamClosed.catch(() => { /* Ignore the error */ });

              // obj.writer.close();
              //  await obj.writableStreamClosed;
              //  await obj.port.close();
            });
            
        });
        
    </script>
</html>
